---
toc: true
toc_sticky: true
categories:
- Computer Networking
title: "컴퓨터 네트워킹, [CHAPTER 02] 애플리케이션 레이어"
---

## 2.1 네트워크 애플리케이션의 원리
- **네트워크 애플리케이션**
    - 다른 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램 -> 여러 종단 시스템에서 실행 가능 해야함
    - 네트워크 코어 장비는 네트워크 계층 및 그 하위 계층에서 기능 -> 소프트웨어 작성 시 네트워크 코어 장비를 고려할 필요는 없음

### 2.1.1 네트워크 애플리케이션 구조

- **클라이언트-서버 구조**<br>
    - **서버** : 항상 켜져 있는 호스트, 많은 클라이언트의 요청을 처리, 고정 IP 소유
    - **클라이언트** : 서버에게 요청, 클라이언트끼리 직접적인 통신 불가능
    - **데이터센터** : 하나의 서버로 모든 요청을 처리 할 수 없을 때 사용, 10만 개 정도의 서버로 구성 
    
- **P2P 구조**<br>
    - **피어**
        - 간헐적으로 연결된 호스트 쌍
        - 서버에 최소로 의존하거나 전혀 의존하지 않음
        - 피어끼리 직접 통신
    - **애플리케이션** : 파일 공유(토렌트 등), 피어-지원 다운로드 가속기(쉰레이 등), 인터넷 전화 및 비디오 컨퍼런스(스카이프 등)
    - **자가 확장성** : 각 피어들이 파일을 요구함으로써 작업 부하를 생성하지만 파일을 다른 피어들에게 분배함 -> 시스템에 서비스 능력 추가
    - **비용 효율성** : 일반적으로 상당한 서버 기반구조와 서버 대역폭을 요구하지 않음

### 2.1.2 프로세스 간 통신
- **프로세스** 
    - 종단 시스템에서 실행되는 프로그램
    - 컴퓨터 네트워크를 통한 메시지 교환으로 통신

- **클라이언트와 서버 프로세스**<br>
    - **클라이언트**
        - 통신 세션에서 통신을 초기화하는 프로세스
        - 웹에서 브라우저가 클라이언트 프로세스
        - P2P에선 파일을 내려받는 피어가 클라이언트 프로세스
    - **서버**
        - 세션을 시작하기 위해 접속을 기다리는 프로세스
        - P2P에서 파일을 올리는 피어가 서버 프로세스

- **프로세스와 컴퓨터 네트워크 사이의 인터페이스**<br>
    - **소켓**
        - 프로세스는 소켓을 통해 네트워크로 메시지를 교환
        - 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
        - 애플리케이션과 네트워크 사이의 API
        - 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못함

- **프로세스 주소 배정**<br>
    - **IP주소** : 호스트를 식별하기 위한 주소
    - **포트번호** : 수신 프로세스를 식별하기 위한 주소

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
- **신뢰적 데이터 전송**<br>
    - 프로토콜이 데이터를 책임지고 전송하는 서비스
    - **손실 허용 애플리케이션**
        - 실시간 오디오/비디오와 같은 일부 멀티미디어 애플리케이션
        - 신뢰적 데이터 전송을 제공하지 않아도 큰 문제가 없음

- **처리율**<br>
    - **가용한 처리율**
        - 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
        - 시간에 따라 변동 -> 트랜스포트 프로토콜이 가용한 처리율을 일정 수준으로 보장하는 서비스를 제공 가능
    - **대역폭 민감 애플리케이션**
        - 가용한 처리율을 일정 수준 이상으로 요구하는 애플리케이션
        - 많은 현존하는 멀티미디어 애플리케이션은 대역폭에 민감
    - **탄력적 애플리케이션**
        - 요구 하는 가용한 처리율이 없는 애플리케이션
        - 전자메일, 파일 전송, 웹 전송 등 융통성 있는 애플리케이션들이 해당

- **시간**<br>
    - 트랜스포트 프로토콜은 시간 보장 가능
    - 실시간 애플리케이션의 경우 데이터 전송에 엄격한 시간제한 조건을 요구
    - 비실시간 애플리케이션은 실시간 애플리케이션 만큼 종단간 지연에 엄격한 제약을 받지 않음

- **보안**<br>
    - 트랜스포트 프로토콜은 하나 이상의 보안 서비스 제공 가능
    - 비밀성, 데이터 무결성, 종단 인증 등

### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

- **TCP 서비스**<br>
    - **연결지향형 서비스**<br>
        - **핸드셰이킹** :  메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환
        - **TCP 연결**
            - 셰이킹이 끝나면 TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 얘기
            - 두 프로세스가 서로에게 동시에 메시지를 보낼 수 있기에 전이중 연결
        - 메시지 전송이 끝나면 연결을 끊음
    - **신뢰적인 데이터 전송 서비스**<br>
        - 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림을 손실하거나 중복되지 않게 수신 소켓으로 전달
    - **혼잡 제어 서비스**<br>
        - 프로세스 관점의 이득보다 인터넷의 전체 성능 향상을 위한 서비스
        - 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춤
    - **보안 서비스**<br>
        - TCP 프로토콜은 보안 서비스를 제공하지 않음
        - **SSL**
            - 인터넷 프랜스포트 프로토콜이 아니라 애플리케이션 계층에서 구현된 것으로 TCP를 보완하는 역할
            - 기존 TCP가 하는 모든 것을 할 뿐만 아니라 암호화, 데이터 무결성 그리고 종단 인증을 포함하는 보안 서비스를 제공

- **UDP 서비스**<br>
    - TCP와 반대되는 특징
    - 핸드셰이킹 x
    - 비신뢰적인 데이터 전송 서비스
    - 수신 소켓의 메시지 도착이나 메시지 순서를 보장하지 않음
    - 혼잡 제어 x -> 네트워크 상태에 상관없이 프로세스 속도를 유지

- **인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스**
    - TCP와 UDP는 처리율 보장, 시간 보장 서비스를 제공하지 않음
    - 인터넷은 여러해 동안 시간 민감 애플리케이션을 서비스 -> 이들 애플리케이션은 이러한 보장이 없는 경우에도 가능한 잘 대처할 수 있도록 설계됨
    - 지연이 과도할 때 한계가 존재

### 2.1.5 애플리케이션 계층 프로토콜
- 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의
    1. 교환 메시지 타입
    2. 여러 메시지 타입의 문법
    3. 필드에 있는 정보의 의미
    4. 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
- 네트워크 애플리케이션의 한 요소

## 2.2 웹과 HTTP

### 2.2.1 HTTP 개요

- **HTTP**
    1. 클라이언트 프로그램과 서버 프로그램으로 구현
    2. 두 프로그램은 HTTP 메시지를 교환하여 통신
    3. 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의
    4. TCP를 전송 프로토콜로 사용 -> HTTP는 데이터의 손실과 데이터 복구, 데이터 순서 등에 대해 걱정할 필요가 없음
    5. **비상태 프로토콜** : HTTP 서버는 클라이언트에 대한 정보를 유지하지 않음

- **웹 페이지** : 기본 HTML 파일과 여러 참조 객체들로 구성
    1. **객체** : 단순히 단일 URL로 지정할 수 있는 하나의 파일    
    2. **기본 HTML파일** : 페이지 내부의 다른 객체를 그 객체의 URL로 참조
    3. **URL** : 객체를 갖고 있는 서버의 호스트 네임과 객체의 경로 이름을 갖고 있음

- **웹 프라우저**
    1. HTTP의 클라이언트 측을 구현
    2. 요구한 웹 페이지를 보여 주고 여러 가지 인터넷 항해와 구성 특성 제공

- **웹 서버**
    1. HTTP의 서버 측을 구현
    2. URL로 각각을 지정할 수 있는 웹 객체를 갖고 있음
    3. 아파치, IIS 등

### 2.2.2 비지속 연결과 지속 연결

- **비지속 연결 HTTP**
    
    - **예시 가정**
        - 페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성
        - 이 11개 객체가 같은 서버에 존재
        - HTML 파일의 URL : http://www.someSchool.edu/someDepartment/home.index
    
    - **연결 수행 과정**
        1. 클라이언트는 포트 번호 80을 통해 www.someSchool.edu 서버로 TCP 연결 시도(세 방향 핸드셰이크) -> TCP 연결을 위한 소켓이 클라이언트와 서버에 설정됨
        2. 클라이언트는 소켓을 통해 서버로 HTTP 요청 메시지를 보냄
        3. 서버는 소켓을 통해 요청 메시지를 받음 -> 저장장치로부터 /someDepartment/home.index 객체를 추출 -> 응답 메시지에 그 객체를 캡슐화 -> 응답 메시지를 소켓을 통해 클라이언트로 보냄
        4. 서버는 TCP에게 TCP 연결을 끊으라고 함
        5. 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단됨 -> 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하여 10개의 JPEG 객체에 대한 참조를 찾음
        6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복

    - **예시 분석**
        - 서버가 객체를 보낸 후에 각 TCP 연결이 끊어지므로 비지속 연결
        - 이 예시에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결 생성
        - 사용자는 TCP 연결의 동시성 정도를 조절 가능 -> 동시 연결 사용시 응답 시간 감소

    - **RTT** : 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간
    - **총응답 시간** : 대략 2 RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것
    
    - **단점**
        1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 함 -> 웹 서버에 부담
        2. 각 객체는 2 RTT를 필요

- **지속 연결 HTTP**

    - **HTTP1.1 지속 연결**
        - 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지 -> 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보냄
        - **파이프라이닝** : 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어짐

### 2.2.3 HTTP 메시지 포맷

- **HTTP 요청 메시지**<br>
    ![2.8](/assets/img/2.8.PNG)<br>
    
    ```
    GET/somedir/page.html HTTP/1.1
    Host: www.someschool.edu
    Connection: close
    User-agent: Mozilla/5.0
    Accept-language: fr
    ```
    - ASCII 텍스트로 쓰여 있음
    - 각 줄은 CR과 LF로 구별
    - **요청 라인** : 요청 메시지의 첫 줄로 방식 필드, URL 필드, HTTP버전 필드로 구성 
    - **방식 필드**
        1. **GET 방식**
            - HTTP 메시지의 대부분은 GET 방식
            - 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용
            - 이 예에서 브라우저는 '/somedir/page.html' 객체를 요청
            - HTML 폼 : 요청된 URL의 입력 데이터를 전송
        2. **POST 방식**
            - 사용자가 폼을 채워 넣을 때 쓰는 방식
            - 폼 필드에 입력한 것을 개체 몸체에 포함시킴
        3. **HEAD 방식** 
            - 서버가 요청을 받으면 HTTP 메시지로 응답하지만 객체를 보내지 않음
            - 주로 개발자가 디버깅을 위해 사용
        4. **PUT 방식** : 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용
        5. **DELETE 방식** : 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용

    - **헤더 라인** : 요청 라인 이후의 줄들
        - 'Host: www.someschool.edu' : 객체가 존재하는 호스트
        - 'Connection: close' : 서버에게 지속 연결 사용을 원하지 않음
        - 'User-agent: Mozilla/5.0' : 서버에게 요청을 하는 브라우저 타입이 Mozilla/5.0, 파이어폭스 브라우저
        - 'Accept-language: fr' : 사용가가 객체의 프랑스어 버전을 원함

- **HTTP 응답 메시지**
    ![2.9](/assets/img/2.9.PNG)<br>
    ```
    HTTP/1.1 200 OK
    Connection: close
    Date: Tue, 18 Aug 2015 15:44:04 GMT
    Server: Apache/2.2.3 (CentOS)
    Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
    Content-Length: 6821
    Content-Type: text/html

    (데이터 데이터 데이터 데이터...)
    ```

    - **상태 라인** : 버전 필드, 상태 코드, 해당 상태 메시지로 구성
    - **상태 코드**
        1. 200 OK : 요청이 성공됐고, 정보가 응답으로 보내짐
        2. 301 Moved Permanetly
            - 요청 객체가 영원히 이동
            - 새로운 URL은 응답 메시지의 Location: 헤더에 포함
        3. 400 Bad Request : 서버가 요청을 이해할 수 없음
        4. 404 Not Found : 요청 문서가 서버에 존재하지 않음
        5. 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않음
    - **헤더 라인**
        1. Connection: close -> 클라이언트에게 메시지를 보낸 후 TCP 연결 닫기
        2. Date: -> HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간
        3. Server: -> 메시지가 아파치 웹 서버에 의해 만들어짐
        4. Last-Modified: -> 객체가 생성되거나 마지막으로 수정된 시간과 날짜
        5. Content-Length: -> 송신되는 객체의 바이트 수
        6. Content-Type: -> 개체 몸체 내부의 객체가 HTML 텍스트

### 2.2.4 사용자와 서버 간의 상호작용: 쿠키
![2.10](/assets/img/2.10.PNG)

- **쿠키** : 사이트가 사용자 추척을 가능하게 해줌
    1. 한 사용자가 처음으로 아마존에 접속 했다고 가정
    2. 과거에 이베이 사이트를 방문한 적이 있음
    3. 아마존 웹 서버에 요청이 들어오면 사용자를 식별하기 위한 번호(1678) 생성
    4. 식별 번호로 인덱스되는 백엔드 데이터베이스 안에 엔트리 생성
    5. 그 후 아마존 웹 서버는 사용자의 브라우저에 Set-cookie: 1678 헤더를 포함한 메시지로 응답
    6. 사용자의 브라우저는 쿠키를 관리하는 파일에 Set-cookie: 헤더와 식별번호를 추가
    7. 사용자가 아마존을 다시 방문할 때 마다 HTTP 요청에 Cookie: 1678과 같은 헤더 라인을 포함

### 2.2.5 웹 캐싱
- **웹 캐시** 
    - 웹 서버를 대신하여 HTTP 요구를 충족
    - 자체 저장 디스크에 최근 호출된 객체의 사본을 저장 및 보존
    - 프록시 서버라고도 함
    - 서버이면서 클라이언트
    - 일반적으로 ISP가 구입하고 설치
    - 장점
        1. 클라이언트의 요구에 대한 응답 시간 감소
        2. 한 기관에서 인터넷으로 접속하는 링크상의 웹 트래픽을 대폭 감소

- **웹 캐시를 통한 클라이언트의 객체 요청**
    ![2.11](/assets/img/2.11.PNG)
    1. 브라우저는 웹 캐시와 TCP 연결을 설정 후 웹 캐시에 있는 객체에 대한 HTTP 요청
    2. 웹 캐시는 객체의 사본이 자기에게 저장돼 있는지 확인하고 저장돼 있다면 브라우저로 HTTP 응답 메시지와 함께 객체를 전송
    3. 웹 캐시가 객체를 가지고 있지 않다면, 웹 캐시는 원출처 서버로 TCP 연결을 설정한 후 객체에 대한 HTTP 요청을 보냄
    4. 요청을 받은 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보냄
    5. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사 후 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보냄

- **조건부 GET** 
    - 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식
    - 메시지 형태
        1. GET 방식 사용
        2. If-Modified-Since: 헤더 라인을 포함

## 2.3 인터넷 전자메일
- **인터넷 전자메일 시스템 구조**
    ![2.14](/assets/img/2.14.PNG)
    1. 사용자 에이전트 : 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해줌
    2. 메일 서버 : 메일 박스와 메시지 큐로 구성
    3. SMTP : 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜

### 2.3.1 SMTP
- 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송
- **SMTP의 기본 동작**
    ![2.15](/assets/img/2.15.PNG)
    1. 앨리스는 전자메일 사용자 에이전트를 수행, 밥의 전자메일 주소를 제공, 메시지를 작성하고 사용자 에이전트에게 메시지를 보내라고 명령
    2. 메시지를 그녀의 메일 서버에게 보내고 메시지는 메시지 큐에 놓임
    3. SMTP의 클라이언트 측은 메시지 큐에 있는 메시지를 보고 밥의 메일 서버에서 수행되고 있는 SMTP 서버에게 TCP 연결을 설정
    4. SMTP 핸드셰이킹 후에 앨리스의 메시지를 TCP 연결로 보냄
    5. SMTP 서버 측은 메시지를 수신하고 밥의 메일 서버는 그 메시지를 밥의 메일박스에 저장
    6. 밥은 편한 시간에 그 메시지를 일기 위해 사용자 에이전트를 시동

- **SMTP 클라이언트와 SMTP 서버 사이의 메시지 전달**
    ![01](/assets/img/01.PNG)
    - 클라이언트 호스트 네임 : crepes.fr, 서버의 호스트 네임 : hamburger.edu
    - "Do you like ketchup? How about pickles?" 메시지를 전송
    - 클라이언트는 HELO, MAIL FROM, RCPT TO, DATA, QUIT 명령 사용
    - 하나의 점으로 된 라인 송신 -> 메시지의 끝
    - SMTP는 지속 연결 사용 

### 2.3.2 HTTP와의 비교
- 공통점
    1. 한 호스트에서 다른 호스트로 파일을 전송
    2. 지속 연결 사용 (지속 HTTP의 경우)

- 차이점<br>

||SMTP|HTTP|
|:------:|:------:|:------:|
|푸시와 풀|푸시|풀|
|메시지 포맷|7bit ASCII|제한 없음|
|객체|모든 메시지의 객체를 한 메시지로|응답 메시지에 각 객체를 캡슐화|

### 2.3.3 메일 메시지 포맷
![02](/assets/img/02.PNG)
1. 메일을 보낼 때 주변 정보가 포함된 헤더가 메시지 몸체 앞에 온다
2. 헤더 라인과 메시지 몸체는 빈 줄(CRLF)로 분리
3. 모든 헤더는 From: 헤더 라인과 To: 헤더 라인을 반드시 가져야 한다 

### 2.3.4 메일 접속 프로토콜
![2.16](/assets/img/2.16.PNG)
1. 두 단계의 SMTP 절차를 통해 앨리스의 에이전트가 보낸 메시지가 밥의 메일 서버에 도착
2. SMTP는 푸시 프로토콜이므로 POP3, IMAP, HTTP 같은 풀 프로토콜로 밥의 에이전트는 메시지를 가져옴

- **POP**
    1. 인증 : 사용자 이름과 비밀번호 보내 사용자 인증
    2. 트랜잭션 : 사용자 에이전트는 메시지를 가져오거나, 삭제 표지, 통계 얻기 등이 가능
    3. 갱신 : quit 명령이 내려진 후에 발생, 삭제 표시된 메시지를 삭제<br>

- **IMAP**
    1. 폴더에 각각의 메시지 연결
    2. 사용자가 폴더를 생성하고 하나의 폴더에서 다른 폴더로 메시지를 옮기는 명령 제공
    3. 사용자 상태 정보 유지
    4. 사용자 에이전트가 메시지의 구성요소를 얻을 수 있게 허용<br>

- **HTTP**
    1. 사용자 에이전트 : 일반 웹 브라우저
    2. 사용자는 HTTP를 통해 메일 서버에 있는 원격 메일박스와 통신<br>

## 2.4 DNS-인터넷의 디렉터리 서비스

- **호스트 식별**
    1. 호스트 네임 : www.facebook.com, www.google.com 등과 같은 사람이 기억하기 쉬운 식별자
    2. IP 주소 : 121.7.106.82과 같은 형태로 라우터가 처리하기 쉬운 식별자

### 2.4.1 DNS가 제공하는 서비스

- **DNS**
    1. 호스트 네임을 IP 주소로 변환해 주는 디렉터리 서비스 제공
    2. 계층구조로 구현된 분산 데이터베이스
    3. 호스트가 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜

- **DNS로부터 IP를 얻는 과정**
    1. 사용자 컴퓨터는 DNS 애플리케이션의 클라이언트 측 수행
    2. 브라우저는 URL로부터 호스트 네임을 추출하고 DNS 애플리케이션의 클라이언트 측에 넘긴다
    3. DNS 클라이언트는 DNS 서버로 호스트 네임을 포함하는 질의 전송
    4. DNS 클라이언트는 호스트 네임에 대한 IP 주소를 가진 응답 수신

- **DNS가 제공하는 추가 서비스**
    1. 호스트 앨리어싱 : 복잡한 호스트 넴을 가진 호스트는 하나 이상의 별명을 가질 수 있다
    2. 메일 서버 앨리어싱 : 메일 애플리케이션도 별칭 호스트 네임을 가질 수 있고 정식 호스트 네임을 얻기 위해 DNS 사용
    3. 부하 분산 : 클라이언트가 여러 주소 집합으로 매핑되는 중복 웹 서버의 호스트 네임에 대한 질의를 하면, 서버는 IP 주소 집합 전체로 응답

### 2.4.2 DNS 동작 원리 개요

- **과정**
    1. 애플리케이션은 변환될 호스트 네임을 명시하여 DNS 측의 클라이언트 호출
    2. 사용자 호스트의 포트 53의 UDP 데이터그램 형태로 DNS는 네트워크에 질의 메시지 전송
    3. 수 msec에서 수 sec의 지연 후 사용자 호스트의 DNS는 요청한 매핑에 해당하는 DNS 응답 메시지를 수신

- **DNS가 하나의 인터넷 네임 서버가 아닌 이유**
    1. 서버의 고장 : 네임 서버 고장 시 전체 인터넷이 작동 불가
    2. 트래픽 양 :단일 DNS 서버가 모든 DNS 질의 처리
    3. 먼 거리의 중앙 집중 데이터베이스 : 단일 DNS 서버가 모든 질의 클라이언트로부터 가까운 것이 아니다
    4. 유지관리 : 모든 인터넷 호스트에 대한 레코드를 유지<br>

    요약하면 확장성이 전혀 없다. 따라서 분산되도록 설계됐다

- **분산 계층 데이터베이스**<br>
    ![2.17](/assets/img/2.17.PNG)<br>
    어떤 DNS 클라리언트가 호스트 네임 www.amazon.com의 IP 주소를 결정하기 원한다고 가정<br>

    1. 루트 서버 중 하나에 접속
    2. 최상위 레벨 도메인 com을 갖는 TLD(Top Level Domain)서버 IP주소를 전송
    3. 클라이언트는 이 TLD 서버 중 하나에 접속, 서버는 도메인 amazon.com을 가진 책임 서버의 IP 주소를 전송
    4. 클라이언트는 amazon.com의 책임 서버 중에서 하나로 접속
    5. 서버는 www.amazon.com의 IP 주소를 전송

- **DNS 서버 종류**
    1. 루트 DNS 서버 : 13개의 다른 기관에서 관리되는 루트 네임 서버
    2. 최상위 레벨 도메인(TLD) : com, org, net, edu 같은 상위 레벨 도메인과 kr, uk, fr, ca, jp 같은 모든 국가의 상위 레벨 도메인에 대한 서버
    3. 책임 DNS 서버 : 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 네임을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다
    4. 로컬 DNS 서버 : 호스트가 ISP에 연결될 때, 그 ISP는 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공

- **DNS 서버들의 상호작용**<br>
    ![2.19](/assets/img/2.19.PNG)<br>

    1. 호스트가 DNS 질의를 보내면, 이 질의는 먼저 프록시로 동작하는 로컬 DNS 서버에게 전달되고, 그 로컬 DNS 서버는 이 질의를 DNS 서버 계층으로 전달
    2. 재귀적 질의(자신을 대신하여 필요한 매핑을 얻는 것)와 반복적 질의(필요한 매핑을 직접 얻는 것) 사용

- **DNS 캐싱**<br>
    1. 질의 사슬에서 DNS 서버가 DNS 응답을 받았을 때, 그것은 로컬 메모리에 응답에 대한 정보를 저장할 수 있다
    2. 호스트 DNS와 IP 주소 사이의 매핑과 호스트는 영구적이지 않기 때문에 일정 기간 이후 저장된 정보를 삭제

### 2.4.3 DNS 레코드와 메시지
1. 호스트 네임을 IP 주소로 매핑하기 위한 자원 레코드를 저장
2. (Name, Value, Type, TTL)과 같은 튜플로 구성

- **Type 종류**
    1. Type=A
        - Name : 호스트 네임
        - Value : 호스트 네임에 대한 IP 주소
    2. Type=NS
        - Name : 도메인
        - Value : 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 네임
    3. Type=CNAME
        - Name : 별칭 호스트 네임
        - Value : 정식 호스트 네임
    4. Type=MX
        - Name : 메일 서버의 별칭 호스트 네임
        - Value : 정식 메일 서버의 네임

- **DNS 메시지**<br>
    ![2.21](/assets/img/2.21.PNG)<br>

    1. 헤더 영역
        - 12 바이트로 구성된 가장 앞 부분
        - Identification : 질의를 식별하는 16비트 숫자
        - Flags : 질의/응답, 책임, 재귀 요구, 재귀 가능 플래그 존재
        - Number fields : 4개 존재, 헤더 다음에 오는 데이터 평면의 네 가지 타입의 발생 횟수 표현
    2. 질문 영역
        - 질의되는 이름을 포함하는 필드 포함
        - 이름에 대해 문의되는 질문 타입을 나타내는 타입 필드 포함
    3. 답변 영역
        - 원래 질의된 이름에 대한 자원 레코드 포함
        - 응답으로 여러 개의 RR 전송 가능
    4. 책임 영역
        - 다른 책임 서버의 레코드 포함
    5. 추가 영역
        - 다른 도움이 되는 레코드 포함

- **DNS 데이터베이스에 레코드 삽입**<br>
    1. 등록기관은 도메인 네임의 유일성을 확인
    2. 그 도메인 이름을 DNS 데이터베이스에 넣는다
    3. 등록 서비스에 대해 요금을 받는 상업 기관

## 2.5 P2P 파일 분배
1. P2P 구조는 항상 켜져 있는 기반구조 서버에 최소한으로 의존
2. 피어가 서로 직접 통신
3. 사용자가 제어하는 데스크톱과 랩톱이 피어를 소유

### P2P 구조의 확장성<br>
![2.22](/assets/img/2.22.PNG)<br>
한 파일을 고정된 수의 피어들에게 분배하는 간단한 양적 모델을 고려<br>

- **분배 시간**<br>
    ![2.23](/assets/img/2.23.PNG)<br>

    1. 클라이언트-서버 구조<br>
        ![2.1](/assets/img/2.1.PNG)<br>
        - 분배 시간은 피어의 수 N에 따라 선형적으로 증가
    2. P2P 구조<br>
        ![2.3](/assets/img/2.3.PNG)<br>
        - 피어의 수 N이 일정 크기 이상이면 분배 시간은 아주 천천히 증가
        - 피어가 소비자이자 재분배자가 되어 P2P 구조의 애플리케이션은 자가 확장성을 가진다

### 비트토렌트<br>
![2.24](/assets/img/2.24.PNG)<br>

1. 파일 분배를 위한 P2P 프로토콜
2. 토렌트 : 파일의 분배에 참여하는 모든 피어들의 모임
3. 피어들은 서로에게서 같은 크기의 청크를 다운로드
4. 트랙커 : 기반구조 노드로 피어가 토렌트에 가입할 때 트랙커에 자신을 등록하고 주기적으로 자신이 토렌트에 있음을 알린다

- **가입**
    1. 트랙커는 참여 중인 피어 집합에서 임의로 피어들의 부분 집합을 선택하여 피어들의 IP주소를 가입 피어에게 전송
    2. 모든 피어들과 동시에 TCP 연결 설정하고 연결 설정된 피어들은 이웃 피어가 된다
    3. 시간이 지나면서 피어 중 일부는 떠나고 다른 피어들이 TCP 연결을 시도하면서 피어의 이웃 피어가 시간에 따라 변동

- **요청**
    1. 주기적으로 이웃 피어들로부터 청크리스트를 얻고 갖고 있지 않은 청크에 대해 요구
    2. 피어들 중 가장 드문 청크부터 요청하여 토렌트에 각 청크의 복사본 수가 균등해진다

- **TFT (tit-for-tat)**
    1. 가장 빠른 속도로 요청에 대한 데이터를 제공하는 이웃에게 우선순위를 부여
    2. 빠르게 전송하는 4개의 피어들로 활성화 피어 집합을 생성
    3. 30초마다 임의로 하나의 피어를 추가로 선택하여 새로운 피어에게 청크를 전송하고 그 청크도 데이터를 전송
    4. 임의 청크의 데이터 전송 속도가 충분히 높으면 활성화 피어 집합을 갱신
    5. 결국엔 양립할 수 있는 속도로 업로드할 능력을 가진 피어들끼리 구성된다






