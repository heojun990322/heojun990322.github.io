---
toc: true
toc_sticky: true
categories:
- Computer Networking
title: "컴퓨터 네트워킹, [CHAPTER 02] 애플리케이션 레이어"
---

## 2.1 네트워크 애플리케이션의 원리
- **네트워크 애플리케이션**
    - 다른 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램 -> 여러 종단 시스템에서 실행 가능 해야함
    - 네트워크 코어 장비는 네트워크 계층 및 그 하위 계층에서 기능 -> 소프트웨어 작성 시 네트워크 코어 장비를 고려할 필요는 없음

### 2.1.1 네트워크 애플리케이션 구조

- **클라이언트-서버 구조**<br>
    - **서버** : 항상 켜져 있는 호스트, 많은 클라이언트의 요청을 처리, 고정 IP 소유
    - **클라이언트** : 서버에게 요청, 클라이언트끼리 직접적인 통신 불가능
    - **데이터센터** : 하나의 서버로 모든 요청을 처리 할 수 없을 때 사용, 10만 개 정도의 서버로 구성 
    
- **P2P 구조**<br>
    - **피어**
        - 간헐적으로 연결된 호스트 쌍
        - 서버에 최소로 의존하거나 전혀 의존하지 않음
        - 피어끼리 직접 통신
    - **애플리케이션** : 파일 공유(토렌트 등), 피어-지원 다운로드 가속기(쉰레이 등), 인터넷 전화 및 비디오 컨퍼런스(스카이프 등)
    - **자가 확장성** : 각 피어들이 파일을 요구함으로써 작업 부하를 생성하지만 파일을 다른 피어들에게 분배함 -> 시스템에 서비스 능력 추가
    - **비용 효율성** : 일반적으로 상당한 서버 기반구조와 서버 대역폭을 요구하지 않음

### 2.1.2 프로세스 간 통신
- **프로세스** 
    - 종단 시스템에서 실행되는 프로그램
    - 컴퓨터 네트워크를 통한 메시지 교환으로 통신

- **클라이언트와 서버 프로세스**<br>
    - **클라이언트**
        - 통신 세션에서 통신을 초기화하는 프로세스
        - 웹에서 브라우저가 클라이언트 프로세스
        - P2P에선 파일을 내려받는 피어가 클라이언트 프로세스
    - **서버**
        - 세션을 시작하기 위해 접속을 기다리는 프로세스
        - P2P에서 파일을 올리는 피어가 서버 프로세스

- **프로세스와 컴퓨터 네트워크 사이의 인터페이스**<br>
    - **소켓**
        - 프로세스는 소켓을 통해 네트워크로 메시지를 교환
        - 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
        - 애플리케이션과 네트워크 사이의 API
        - 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못함

- **프로세스 주소 배정**<br>
    - **IP주소** : 호스트를 식별하기 위한 주소
    - **포트번호** : 수신 프로세스를 식별하기 위한 주소

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
- **신뢰적 데이터 전송**<br>
    - 프로토콜이 데이터를 책임지고 전송하는 서비스
    - **손실 허용 애플리케이션**
        - 실시간 오디오/비디오와 같은 일부 멀티미디어 애플리케이션
        - 신뢰적 데이터 전송을 제공하지 않아도 큰 문제가 없음

- **처리율**<br>
    - **가용한 처리율**
        - 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
        - 시간에 따라 변동 -> 트랜스포트 프로토콜이 가용한 처리율을 일정 수준으로 보장하는 서비스를 제공 가능
    - **대역폭 민감 애플리케이션**
        - 가용한 처리율을 일정 수준 이상으로 요구하는 애플리케이션
        - 많은 현존하는 멀티미디어 애플리케이션은 대역폭에 민감
    - **탄력적 애플리케이션**
        - 요구 하는 가용한 처리율이 없는 애플리케이션
        - 전자메일, 파일 전송, 웹 전송 등 융통성 있는 애플리케이션들이 해당

- **시간**<br>
    - 트랜스포트 프로토콜은 시간 보장 가능
    - 실시간 애플리케이션의 경우 데이터 전송에 엄격한 시간제한 조건을 요구
    - 비실시간 애플리케이션은 실시간 애플리케이션 만큼 종단간 지연에 엄격한 제약을 받지 않음

- **보안**<br>
    - 트랜스포트 프로토콜은 하나 이상의 보안 서비스 제공 가능
    - 비밀성, 데이터 무결성, 종단 인증 등

### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

- **TCP 서비스**<br>
    - **연결지향형 서비스**<br>
        - **핸드셰이킹** :  메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환
        - **TCP 연결**
            - 셰이킹이 끝나면 TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 얘기
            - 두 프로세스가 서로에게 동시에 메시지를 보낼 수 있기에 전이중 연결
        - 메시지 전송이 끝나면 연결을 끊음
    - **신뢰적인 데이터 전송 서비스**<br>
        - 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림을 손실하거나 중복되지 않게 수신 소켓으로 전달
    - **혼잡 제어 서비스**<br>
        - 프로세스 관점의 이득보다 인터넷의 전체 성능 향상을 위한 서비스
        - 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춤
    - **보안 서비스**<br>
        - TCP 프로토콜은 보안 서비스를 제공하지 않음
        - **SSL**
            - 인터넷 프랜스포트 프로토콜이 아니라 애플리케이션 계층에서 구현된 것으로 TCP를 보완하는 역할
            - 기존 TCP가 하는 모든 것을 할 뿐만 아니라 암호화, 데이터 무결성 그리고 종단 인증을 포함하는 보안 서비스를 제공

- **UDP 서비스**<br>
    - TCP와 반대되는 특징
    - 핸드셰이킹 x
    - 비신뢰적인 데이터 전송 서비스
    - 수신 소켓의 메시지 도착이나 메시지 순서를 보장하지 않음
    - 혼잡 제어 x -> 네트워크 상태에 상관없이 프로세스 속도를 유지

- **인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스**
    - TCP와 UDP는 처리율 보장, 시간 보장 서비스를 제공하지 않음
    - 인터넷은 여러해 동안 시간 민감 애플리케이션을 서비스 -> 이들 애플리케이션은 이러한 보장이 없는 경우에도 가능한 잘 대처할 수 있도록 설계됨
    - 지연이 과도할 때 한계가 존재

### 2.1.5 애플리케이션 계층 프로토콜
- 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의
    1. 교환 메시지 타입
    2. 여러 메시지 타입의 문법
    3. 필드에 있는 정보의 의미
    4. 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
- 네트워크 애플리케이션의 한 요소

## 2.2 웹과 HTTP

### 2.2.1 HTTP 개요

- **HTTP**
    1. 클라이언트 프로그램과 서버 프로그램으로 구현
    2. 두 프로그램은 HTTP 메시지를 교환하여 통신
    3. 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의
    4. TCP를 전송 프로토콜로 사용 -> HTTP는 데이터의 손실과 데이터 복구, 데이터 순서 등에 대해 걱정할 필요가 없음
    5. **비상태 프로토콜** : HTTP 서버는 클라이언트에 대한 정보를 유지하지 않음

- **웹 페이지** : 기본 HTML 파일과 여러 참조 객체들로 구성
    1. **객체** : 단순히 단일 URL로 지정할 수 있는 하나의 파일    
    2. **기본 HTML파일** : 페이지 내부의 다른 객체를 그 객체의 URL로 참조
    3. **URL** : 객체를 갖고 있는 서버의 호스트 네임과 객체의 경로 이름을 갖고 있음

- **웹 프라우저**
    1. HTTP의 클라이언트 측을 구현
    2. 요구한 웹 페이지를 보여 주고 여러 가지 인터넷 항해와 구성 특성 제공

- **웹 서버**
    1. HTTP의 서버 측을 구현
    2. URL로 각각을 지정할 수 있는 웹 객체를 갖고 있음
    3. 아파치, IIS 등

### 2.2.2 비지속 연결과 지속 연결

- **비지속 연결 HTTP**
    
    - **예시 가정**
        - 페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성
        - 이 11개 객체가 같은 서버에 존재
        - HTML 파일의 URL : http://www.someSchool.edu/someDepartment/home.index
    
    - **연결 수행 과정**
        1. 클라이언트는 포트 번호 80을 통해 www.someSchool.edu 서버로 TCP 연결 시도(세 방향 핸드셰이크) -> TCP 연결을 위한 소켓이 클라이언트와 서버에 설정됨
        2. 클라이언트는 소켓을 통해 서버로 HTTP 요청 메시지를 보냄
        3. 서버는 소켓을 통해 요청 메시지를 받음 -> 저장장치로부터 /someDepartment/home.index 객체를 추출 -> 응답 메시지에 그 객체를 캡슐화 -> 응답 메시지를 소켓을 통해 클라이언트로 보냄
        4. 서버는 TCP에게 TCP 연결을 끊으라고 함
        5. 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단됨 -> 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하여 10개의 JPEG 객체에 대한 참조를 찾음
        6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복

    - **예시 분석**
        - 서버가 객체를 보낸 후에 각 TCP 연결이 끊어지므로 비지속 연결
        - 이 예시에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결 생성
        - 사용자는 TCP 연결의 동시성 정도를 조절 가능 -> 동시 연결 사용시 응답 시간 감소

    - **RTT** : 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간
    - **총응답 시간** : 대략 2 RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것
    
    - **단점**
        1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 함 -> 웹 서버에 부담
        2. 각 객체는 2 RTT를 필요

- **지속 연결 HTTP**

    - **HTTP1.1 지속 연결**
        - 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지 -> 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보냄
        - **파이프라이닝** : 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어짐

### 2.2.3 HTTP 메시지 포맷

- **HTTP 요청 메시지**<br>
    ![2.8](/assets/img/2.8.PNG)<br>
    
    ```
    GET/somedir/page.html HTTP/1.1
    Host: www.someschool.edu
    Connection: close
    User-agent: Mozilla/5.0
    Accept-language: fr
    ```
    1. ASCII 텍스트로 쓰여 있음
    2. 각 줄은 CR과 LF로 구별
    3. **요청 라인** : 요청 메시지의 첫 줄
        - 방식 필드, URL 필드, HTTP버전 필드로 구성 
        - **방식 필드** : GET, POST, HEAD, PUT 그리고 DELETE를 포함하는 여러 가지 값을 가질 수 있음
        - **GET 방식**
            - HTTP 메시지의 대부분은 GET 방식
            - 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용
            - 이 예에서 브라우저는 '/somedir/page.html' 객체를 요청
    4. **헤더 라인** : 요청 라인 이후의 줄들
        - 'Host: www.someschool.edu' : 객체가 존재하는 호스트
        - 'Connection: close' : 서버에게 지속 연결 사용을 원하지 않음
        - 'User-agent: Mozilla/5.0' : 서버에게 요청을 하는 브라우저 타입이 Mozilla/5.0, 파이어폭스 브라우저
        - 'Accept-language: fr' : 사용가가 객체의 프랑스어 버전을 원함
