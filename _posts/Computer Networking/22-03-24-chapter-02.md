---
toc: true
toc_sticky: true
categories:
- Computer Networking
title: "컴퓨터 네트워킹, [CHAPTER 02] 애플리케이션 레이어"
---

## 2.1 네트워크 애플리케이션의 원리
- **네트워크 애플리케이션**
    - 다른 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램 -> 여러 종단 시스템에서 실행 가능 해야함
    - 네트워크 코어 장비는 네트워크 계층 및 그 하위 계층에서 기능 -> 소프트웨어 작성 시 네트워크 코어 장비를 고려할 필요는 없음

### 2.1.1 네트워크 애플리케이션 구조

- **클라이언트-서버 구조**<br>
    - **서버** : 항상 켜져 있는 호스트, 많은 클라이언트의 요청을 처리, 고정 IP 소유
    - **클라이언트** : 서버에게 요청, 클라이언트끼리 직접적인 통신 불가능
    - **데이터센터** : 하나의 서버로 모든 요청을 처리 할 수 없을 때 사용, 10만 개 정도의 서버로 구성 
    
- **P2P 구조**<br>
    - **피어**
        - 간헐적으로 연결된 호스트 쌍
        - 서버에 최소로 의존하거나 전혀 의존하지 않음
        - 피어끼리 직접 통신
    - **애플리케이션** : 파일 공유(토렌트 등), 피어-지원 다운로드 가속기(쉰레이 등), 인터넷 전화 및 비디오 컨퍼런스(스카이프 등)
    - **자가 확장성** : 각 피어들이 파일을 요구함으로써 작업 부하를 생성하지만 파일을 다른 피어들에게 분배함 -> 시스템에 서비스 능력 추가
    - **비용 효율성** : 일반적으로 상당한 서버 기반구조와 서버 대역폭을 요구하지 않음

### 2.1.2 프로세스 간 통신
- **프로세스** 
    - 종단 시스템에서 실행되는 프로그램
    - 컴퓨터 네트워크를 통한 메시지 교환으로 통신

- **클라이언트와 서버 프로세스**<br>
    - **클라이언트**
        - 통신 세션에서 통신을 초기화하는 프로세스
        - 웹에서 브라우저가 클라이언트 프로세스
        - P2P에선 파일을 내려받는 피어가 클라이언트 프로세스
    - **서버**
        - 세션을 시작하기 위해 접속을 기다리는 프로세스
        - P2P에서 파일을 올리는 피어가 서버 프로세스

- **프로세스와 컴퓨터 네트워크 사이의 인터페이스**<br>
    - **소켓**
        - 프로세스는 소켓을 통해 네트워크로 메시지를 교환
        - 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
        - 애플리케이션과 네트워크 사이의 API
        - 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못함

- **프로세스 주소 배정**<br>
    - **IP주소** : 호스트를 식별하기 위한 주소
    - **포트번호** : 수신 프로세스를 식별하기 위한 주소

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
- **신뢰적 데이터 전송**<br>
    - 프로토콜이 데이터를 책임지고 전송하는 서비스
    - **손실 허용 애플리케이션**
        - 실시간 오디오/비디오와 같은 일부 멀티미디어 애플리케이션
        - 신뢰적 데이터 전송을 제공하지 않아도 큰 문제가 없음

- **처리율**<br>
    - **가용한 처리율**
        - 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
        - 시간에 따라 변동 -> 트랜스포트 프로토콜이 가용한 처리율을 일정 수준으로 보장하는 서비스를 제공 가능
    - **대역폭 민감 애플리케이션**
        - 가용한 처리율을 일정 수준 이상으로 요구하는 애플리케이션
        - 많은 현존하는 멀티미디어 애플리케이션은 대역폭에 민감
    - **탄력적 애플리케이션**
        - 요구 하는 가용한 처리율이 없는 애플리케이션
        - 전자메일, 파일 전송, 웹 전송 등 융통성 있는 애플리케이션들이 해당

- **시간**<br>
    - 트랜스포트 프로토콜은 시간 보장 가능
    - 실시간 애플리케이션의 경우 데이터 전송에 엄격한 시간제한 조건을 요구
    - 비실시간 애플리케이션은 실시간 애플리케이션 만큼 종단간 지연에 엄격한 제약을 받지 않음

- **보안**<br>
    - 트랜스포트 프로토콜은 하나 이상의 보안 서비스 제공 가능
    - 비밀성, 데이터 무결성, 종단 인증 등

### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

- **TCP 서비스**<br>
    - **연결지향형 서비스**<br>
        - **핸드셰이킹** :  메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환
        - **TCP 연결**
            - 셰이킹이 끝나면 TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 얘기
            - 두 프로세스가 서로에게 동시에 메시지를 보낼 수 있기에 전이중 연결
        - 메시지 전송이 끝나면 연결을 끊음
    - **신뢰적인 데이터 전송 서비스**<br>
        - 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림을 손실하거나 중복되지 않게 수신 소켓으로 전달
    - **혼잡 제어 서비스**<br>
        - 프로세스 관점의 이득보다 인터넷의 전체 성능 향상을 위한 서비스
        - 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춤
    - **보안 서비스**<br>
        - TCP 프로토콜은 보안 서비스를 제공하지 않음
        - **SSL**
            - 인터넷 프랜스포트 프로토콜이 아니라 애플리케이션 계층에서 구현된 것으로 TCP를 보완하는 역할
            - 기존 TCP가 하는 모든 것을 할 뿐만 아니라 암호화, 데이터 무결성 그리고 종단 인증을 포함하는 보안 서비스를 제공

- **UDP 서비스**<br>
    - TCP와 반대되는 특징
    - 핸드셰이킹 x
    - 비신뢰적인 데이터 전송 서비스
    - 수신 소켓의 메시지 도착이나 메시지 순서를 보장하지 않음
    - 혼잡 제어 x -> 네트워크 상태에 상관없이 프로세스 속도를 유지

- **인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스**
    - TCP와 UDP는 처리율 보장, 시간 보장 서비스를 제공하지 않음
    - 인터넷은 여러해 동안 시간 민감 애플리케이션을 서비스 -> 이들 애플리케이션은 이러한 보장이 없는 경우에도 가능한 잘 대처할 수 있도록 설계됨
    - 지연이 과도할 때 한계가 존재

### 2.1.5 애플리케이션 계층 프로토콜
- 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의
    1. 교환 메시지 타입
    2. 여러 메시지 타입의 문법
    3. 필드에 있는 정보의 의미
    4. 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
- 네트워크 애플리케이션의 한 요소

## 2.2 웹과 HTTP

### 2.2.1 HTTP 개요

- **HTTP**
    1. 클라이언트 프로그램과 서버 프로그램으로 구현
    2. 두 프로그램은 HTTP 메시지를 교환하여 통신
    3. 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의
    4. TCP를 전송 프로토콜로 사용 -> HTTP는 데이터의 손실과 데이터 복구, 데이터 순서 등에 대해 걱정할 필요가 없음
    5. **비상태 프로토콜** : HTTP 서버는 클라이언트에 대한 정보를 유지하지 않음

- **웹 페이지** : 기본 HTML 파일과 여러 참조 객체들로 구성
    1. **객체** : 단순히 단일 URL로 지정할 수 있는 하나의 파일    
    2. **기본 HTML파일** : 페이지 내부의 다른 객체를 그 객체의 URL로 참조
    3. **URL** : 객체를 갖고 있는 서버의 호스트 네임과 객체의 경로 이름을 갖고 있음

- **웹 프라우저**
    1. HTTP의 클라이언트 측을 구현
    2. 요구한 웹 페이지를 보여 주고 여러 가지 인터넷 항해와 구성 특성 제공

- **웹 서버**
    1. HTTP의 서버 측을 구현
    2. URL로 각각을 지정할 수 있는 웹 객체를 갖고 있음
    3. 아파치, IIS 등

### 2.2.2 비지속 연결과 지속 연결

- **비지속 연결 HTTP**
    
    - **예시 가정**
        - 페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성
        - 이 11개 객체가 같은 서버에 존재
        - HTML 파일의 URL : http://www.someSchool.edu/someDepartment/home.index
    
    - **연결 수행 과정**
        1. 클라이언트는 포트 번호 80을 통해 www.someSchool.edu 서버로 TCP 연결 시도(세 방향 핸드셰이크) -> TCP 연결을 위한 소켓이 클라이언트와 서버에 설정됨
        2. 클라이언트는 소켓을 통해 서버로 HTTP 요청 메시지를 보냄
        3. 서버는 소켓을 통해 요청 메시지를 받음 -> 저장장치로부터 /someDepartment/home.index 객체를 추출 -> 응답 메시지에 그 객체를 캡슐화 -> 응답 메시지를 소켓을 통해 클라이언트로 보냄
        4. 서버는 TCP에게 TCP 연결을 끊으라고 함
        5. 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단됨 -> 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하여 10개의 JPEG 객체에 대한 참조를 찾음
        6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복

    - **예시 분석**
        - 서버가 객체를 보낸 후에 각 TCP 연결이 끊어지므로 비지속 연결
        - 이 예시에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결 생성
        - 사용자는 TCP 연결의 동시성 정도를 조절 가능 -> 동시 연결 사용시 응답 시간 감소

    - **RTT** : 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간
    - **총응답 시간** : 대략 2 RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것
    
    - **단점**
        1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 함 -> 웹 서버에 부담
        2. 각 객체는 2 RTT를 필요

- **지속 연결 HTTP**

    - **HTTP1.1 지속 연결**
        - 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지 -> 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보냄
        - **파이프라이닝** : 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어짐

### 2.2.3 HTTP 메시지 포맷

- **HTTP 요청 메시지**<br>
    ![2.8](/assets/img/2.8.PNG)<br>
    
    ```
    GET/somedir/page.html HTTP/1.1
    Host: www.someschool.edu
    Connection: close
    User-agent: Mozilla/5.0
    Accept-language: fr
    ```
    - ASCII 텍스트로 쓰여 있음
    - 각 줄은 CR과 LF로 구별
    - **요청 라인** : 요청 메시지의 첫 줄로 방식 필드, URL 필드, HTTP버전 필드로 구성 
    - **방식 필드**
        1. **GET 방식**
            - HTTP 메시지의 대부분은 GET 방식
            - 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용
            - 이 예에서 브라우저는 '/somedir/page.html' 객체를 요청
            - HTML 폼 : 요청된 URL의 입력 데이터를 전송
        2. **POST 방식**
            - 사용자가 폼을 채워 넣을 때 쓰는 방식
            - 폼 필드에 입력한 것을 개체 몸체에 포함시킴
        3. **HEAD 방식** 
            - 서버가 요청을 받으면 HTTP 메시지로 응답하지만 객체를 보내지 않음
            - 주로 개발자가 디버깅을 위해 사용
        4. **PUT 방식** : 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용
        5. **DELETE 방식** : 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용

    - **헤더 라인** : 요청 라인 이후의 줄들
        - 'Host: www.someschool.edu' : 객체가 존재하는 호스트
        - 'Connection: close' : 서버에게 지속 연결 사용을 원하지 않음
        - 'User-agent: Mozilla/5.0' : 서버에게 요청을 하는 브라우저 타입이 Mozilla/5.0, 파이어폭스 브라우저
        - 'Accept-language: fr' : 사용가가 객체의 프랑스어 버전을 원함

- **HTTP 응답 메시지**
    ![2.9](/assets/img/2.9.PNG)<br>
    ```
    HTTP/1.1 200 OK
    Connection: close
    Date: Tue, 18 Aug 2015 15:44:04 GMT
    Server: Apache/2.2.3 (CentOS)
    Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
    Content-Length: 6821
    Content-Type: text/html

    (데이터 데이터 데이터 데이터...)
    ```

    - **상태 라인** : 버전 필드, 상태 코드, 해당 상태 메시지로 구성
    - **상태 코드**
        1. 200 OK : 요청이 성공됐고, 정보가 응답으로 보내짐
        2. 301 Moved Permanetly
            - 요청 객체가 영원히 이동
            - 새로운 URL은 응답 메시지의 Location: 헤더에 포함
        3. 400 Bad Request : 서버가 요청을 이해할 수 없음
        4. 404 Not Found : 요청 문서가 서버에 존재하지 않음
        5. 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않음
    - **헤더 라인**
        1. Connection: close -> 클라이언트에게 메시지를 보낸 후 TCP 연결 닫기
        2. Date: -> HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간
        3. Server: -> 메시지가 아파치 웹 서버에 의해 만들어짐
        4. Last-Modified: -> 객체가 생성되거나 마지막으로 수정된 시간과 날짜
        5. Content-Length: -> 송신되는 객체의 바이트 수
        6. Content-Type: -> 개체 몸체 내부의 객체가 HTML 텍스트

### 2.2.4 사용자와 서버 간의 상호작용: 쿠키
![2.10](/assets/img/2.10.PNG)

- **쿠키** : 사이트가 사용자 추척을 가능하게 해줌
    1. 한 사용자가 처음으로 아마존에 접속 했다고 가정
    2. 과거에 이베이 사이트를 방문한 적이 있음
    3. 아마존 웹 서버에 요청이 들어오면 사용자를 식별하기 위한 번호(1678) 생성
    4. 식별 번호로 인덱스되는 백엔드 데이터베이스 안에 엔트리 생성
    5. 그 후 아마존 웹 서버는 사용자의 브라우저에 Set-cookie: 1678 헤더를 포함한 메시지로 응답
    6. 사용자의 브라우저는 쿠키를 관리하는 파일에 Set-cookie: 헤더와 식별번호를 추가
    7. 사용자가 아마존을 다시 방문할 때 마다 HTTP 요청에 Cookie: 1678과 같은 헤더 라인을 포함

### 2.2.5 웹 캐싱
- **웹 캐시** 
    - 웹 서버를 대신하여 HTTP 요구를 충족
    - 자체 저장 디스크에 최근 호출된 객체의 사본을 저장 및 보존
    - 프록시 서버라고도 함
    - 서버이면서 클라이언트
    - 일반적으로 ISP가 구입하고 설치
    - 장점
        1. 클라이언트의 요구에 대한 응답 시간 감소
        2. 한 기관에서 인터넷으로 접속하는 링크상의 웹 트래픽을 대폭 감소

- **웹 캐시를 통한 클라이언트의 객체 요청**
    ![2.11](/assets/img/2.11.PNG)
    1. 브라우저는 웹 캐시와 TCP 연결을 설정 후 웹 캐시에 있는 객체에 대한 HTTP 요청
    2. 웹 캐시는 객체의 사본이 자기에게 저장돼 있는지 확인하고 저장돼 있다면 브라우저로 HTTP 응답 메시지와 함께 객체를 전송
    3. 웹 캐시가 객체를 가지고 있지 않다면, 웹 캐시는 원출처 서버로 TCP 연결을 설정한 후 객체에 대한 HTTP 요청을 보냄
    4. 요청을 받은 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보냄
    5. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사 후 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보냄

- **조건부 GET** 
    - 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식
    - 메시지 형태
        1. GET 방식 사용
        2. If-Modified-Since: 헤더 라인을 포함

## 2.3 인터넷 전자메일
- **인터넷 전자메일 시스템 구조**
    ![2.14](/assets/img/2.14.PNG)
    1. 사용자 에이전트 : 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해줌
    2. 메일 서버 : 메일 박스와 메시지 큐로 구성
    3. SMTP : 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜

### 2.3.1 SMTP
- 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송
- **SMTP의 기본 동작**
    ![2.15](/assets/img/2.15.PNG)
    1. 앨리스는 전자메일 사용자 에이전트를 수행, 밥의 전자메일 주소를 제공, 메시지를 작성하고 사용자 에이전트에게 메시지를 보내라고 명령
    2. 메시지를 그녀의 메일 서버에게 보내고 메시지는 메시지 큐에 놓임
    3. SMTP의 클라이언트 측은 메시지 큐에 있는 메시지를 보고 밥의 메일 서버에서 수행되고 있는 SMTP 서버에게 TCP 연결을 설정
    4. SMTP 핸드셰이킹 후에 앨리스의 메시지를 TCP 연결로 보냄
    5. SMTP 서버 측은 메시지를 수신하고 밥의 메일 서버는 그 메시지를 밥의 메일박스에 저장
    6. 밥은 편한 시간에 그 메시지를 일기 위해 사용자 에이전트를 시동

- **SMTP 클라이언트와 SMTP 서버 사이의 메시지 전달**
    ![01](/assets/img/01.PNG)
    - 클라이언트 호스트 네임 : crepes.fr, 서버의 호스트 네임 : hamburger.edu
    - "Do you like ketchup? How about pickles?" 메시지를 전송
    - 클라이언트는 HELO, MAIL FROM, RCPT TO, DATA, QUIT 명령 사용
    - 하나의 점으로 된 라인 송신 -> 메시지의 끝
    - SMTP는 지속 연결 사용 

### 2.3.2 HTTP와의 비교
- 공통점
    1. 한 호스트에서 다른 호스트로 파일을 전송
    2. 지속 연결 사용 (지속 HTTP의 경우)

- 차이점<br>

||SMTP|HTTP|
|:------:|:------:|:------:|
|푸시와 풀|푸시|풀|
|메시지 포맷|7bit ASCII|제한 없음|
|객체|모든 메시지의 객체를 한 메시지로|응답 메시지에 각 객체를 캡슐화|



