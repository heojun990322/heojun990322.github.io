---
toc: true
toc_sticky: true
categories:
- Computer Networking
title: "컴퓨터 네트워킹, [CHAPTER 03] 트랜스포트 레이어"
---

## 3.1 트랜스포트 계층 서비스 및 개요

- 서로 다른 호스트에서 동작하는 애플리케이션 프로세스들 간의 논리적 통신을 제공
- 종단 시스템에서 구현
- Segment : 트랜스포트 계층 패킷

### 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계<br>

![03.01](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.01.PNG)<br>

- 트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 프로세스들 사이의 논리적 통신 제공
- 네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신 제공

### 3.1.2 인터넷 트랜스포트 계층의 개요

- UDP : 애플리케이션에게 비신뢰적이고 비연결형인 서비스 제공
- TCP
    1. 애플리케이션에게 신뢰적이고 연결지향형 서비스를 제공
    2. 흐름제어, 순서번호, 확인응답, 타이머를 사용하여 데이터가 순서대로 정확하게 전달되도록 처리
    3. 혼잡 제어 가능
- IP
    1. 최선형 전달 서비스
    2. 세그먼트 전달외엔 어떤 보장도 없음
    3. 비신뢰적 서비스

## 3.2 다중화와 역다중화<br>

![03.02](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.02.PNG)<br>

- 역다중화(demultiplexing) : 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
- 다중화(multiplexing) : 소켓으로부터 데이터를 모으고, 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업
- 한 계층 에서의 한 프로토콜이 그 상위 계층의 여러 프로토콜에 의해 사용될 때마다 역다중화, 다중화가 필요함
- 세그먼트의 출발지 포트 번호, 목적지 포트 번호 필드 이용해 다중화<br>

![03.03](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.03.PNG)<br>

### 비연결형 다중화와 역다중화<br>

![03.04](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.04.PNG)<br>

- UDP 소켓의 애플리케이션 데이터 전송 과정
    1. 애플리케이션 데이터, 출발지 포트 번호, 목적지 포트 번호, 그리고 2개의 다른 값을 포함하는 트랜스포트 계층 세그먼트 생성
    2. 만들어진 세그먼트를 네트워크 계층으로 전달
    3. 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하고 수신 호스트로 전달
    4. 세그먼트가 수신 호스트에 도착하면, 세그먼트 안의 목적지 포트 번호를 검사하고 그 세그먼트를 포트로 식별되는 소켓에 전달
- 세그먼트들이 동일한 목적지 IP 주소와 목적지 포트 번호를 가지면 같은 목적지 소켓을 통해 동일한 프로세스로 향한다.
- 출발지 포트 번호는 복귀 주소의 한 부분으로 사용

### 연결지향형 다중화와 역다중화<br>

- TCP 소켓은 UDP 소켓과 다르게 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별
- 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다. 

### 웹 서버와 TCP<br>

![03.05](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.05.PNG)<br>

- 웹 서버는 각각의 연결에 따라서 새로운 프로세스를 만든다.
- 프로세스들은 각자 연결 소켓을 가지며, 이 연결 소켓을 통해서 HTTP 요청을 수신하고, HTTP 응답을 전송한다.
- 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것은 아니다. -> 연결 소켓에 대한 멀티 쓰레딩
- 지속적인 HTTP : 클라이언트와 서버는 동일한 서버 소켓을 통해서 HTTP 메시지를 교환
- 비지속적인 HTTP
    1. 요청/응답마다 새로운 TCP 연결이 생성되고 종료
    2. 빈번한 소켓 생성과 종료는 서버에게 부담

## 3.3 비연결형 트랜스포트 UDP

- UDP는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.
- hand-shake 사용하지 않는다 -> 비연결형
- UDP를 사용하는 애플리케이션 계층 프로토콜<br>

    ![03.06](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.06.PNG)<br>

- UDP의 장점
    1. 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어
    2. 연결 설정을 위한 지연이 없다.
    3. 연결 상태 유지를 위한 자원을 사용하지 않는다.
    4. 작은 패킷 헤더 오버헤드
- 애플리케이션이 UDP를 사용할 때도 신뢰적인 데이터 전송이 가능

### 3.3.1 UDP 세그먼트 구조<br>

![03.07](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.07.PNG)<br>

- 데이터 필드 : 애플리케이션 데이터
- UDP 헤더
    1. 2바이트씩 구성된 4개의 필드를 가진다.
    2. 체크섬 : 세그먼트에 오류가 발생했는지 검사
    3. 길이 필드 : 헤더를 포함하는 UDP 세그먼트의 길이

### 3.3.2 UDP 체크섬

- 오류 검출 제공
- 검출 과정 <br>
    
    ![wrap around](/assets/img/Computer%20Networking/22-05-05-chapter-03/wrap%20around.PNG)<br>

    1. 송신 측에서 세그먼트를 16비트 워드 단위로 더한다.
    2. 이 때 발생하는 오버플로는 wrap around한다.
    3. 모두 더한 후 1의 보수를 수행
- UDP가 오류 검출을 수행하는 이유
    - 하위 계층의 신뢰성과 메모리의 오류 검사가 보장되지 않기 때문에, 종단간의 데이터 전송 서비스가 오류 검사를 제공한다면, UDP는 종단간의 트랜스포트 계층에서 오류 검사를 제공해야만 한다. -> 종단간의 원리(end-end principle)
- 오류를 검출해도 회복하기 위한 어떤 일도 하지 않는다.

## 3.4 신뢰성 있는 데이터 전송의 원리

- 신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않는다. 
- 모든 데이터는 전송된 순서대로 전달된다.
- 신뢰적 서비스의 구현<br>
    
    ![3.8](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.08.PNG)<br>

    1. rdt_send() : 데이터 전송 프로토콜의 송신 측이 호출
    2. rdt_rcv() :  패킷이 채널의 수신 측으로부터 도착했을 때 호출
    3. deliver_data() : 상위 계층에 데이터를 전달하려고 할 때 호출. 
    4. udt_send() : 다른 쪽에 패킷을 전송 

### 3.4.1 신뢰적인 데이터 전달 프로토콜의 구축

1. 완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송 : rdt1.0<br>

    ![3.9](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.09.PNG)<br>

2. 비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송 : rdt2.0<br>

    ![3.10](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.09.PNG)<br>

    - 프로토콜 상태가 현재 전송되고 있거나, 기다리고 있는 패킷이 순서번호 0또는 1을 가져야 하는지를 반영
        1. rdt2.1 송신자<br>

            ![03.11](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.11.PNG)<br>

        2. rdt2.1 수신자<br>

            ![03.12](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.12.PNG)<br>
        
    - 비트 오류를 갖는 채널을 위한 NAK 없는 신뢰적인 데이터 전송 프로토콜
        1. rdt2.2 송신자<br>

            ![03.13](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.13.PNG)<br>

        2. rdt2.2 수신자<br>

            ![03.14](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.14.PNG)<br>

3. 비트 오류와 손실 있는 채널 상에서의 신뢰적 데이터 전송 : rdt3.0

    1. rdt3.0 송신자<br>

        ![03.15](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.15.PNG)<br>

    2. rdt3.0의 동작, 얼터네이팅 비트 프로토콜<br>

        ![03.16](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.16.PNG)<br> 

### 3.4.2 파이프라인된 신뢰적 데이터 전송 프로토콜<br>

![03.18](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.18.PNG)<br>

- stop-and-wait
    1. rdt3.0과 같은 stop-and-wait 방식에서 송신자측은 ACK 패킷을 RTT + L/R 후에 다시 받을 수 있다.
    2. 실제적으로 분주하게 비트를 전송하는데만 걸린 시간은 매우 적다.

- 파이프라이닝
    1. 확인응답을 기다리지 않고 여러 패킷을 전송하도록 허용
    2. 순서번호의 범위가 더 커져야 한다.
    3. 최소한 송신자는 전송되었으나 확인응답 되지 않은 패킷을 버퍼링해야 한다.
    4. 오류 회복의 방법으로 Go-Back-N, Selective Repeat 등이 있다.

### 3.4.3 N부터 반복(Go-Back-N, GBN)<br>

![03.19](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.19.PNG)<br>

- 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.
- 확인응답이 안 된 패킷의 최대 허용 수 N보다 크지 않아야 한다.
- base : 확인응답이 안 된 가장 오래된 패킷의 순서번호
- nextseqnum : 사용되지 않은 가장 작은 순서번호(전송될 다음 패킷의 순서번호)
- 순서 번호 범위
    1. [0, base-1] : 이미 전송되고 확인응답이 된 패킷에 대응
    2. [base, nextseqnum-1] : 송신은 되었지만 아직 확인응답 되지 않은 패킷에 대응
    3. [nextseqnum, base+N-1] : 상위 계층으로부터 데이터가 도착하면 바로 전송될 수 있는 패킷
    4. base+N 이상 : 확인응답 안 된 패킷의 확인응답이 도착될 때까지 사용될 수 없다.
- 윈도우
    1. 위 그림에서 N의 범위
    2. 순서번호 공간에서 오른쪽으로 이동된다.
- 순서번호의 범위 : k가 패킷 순서번호 필드의 비트 수라면 [0, 2^k - 1]
- ACK 기반의 NAK 없는 GBN 프로토콜의 송신 측과 수신 측의 확장된 FSM
    1. 송신자<br>

        ![03.20](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.20.PNG)<br>

    2. 수신자<br>

        ![03.21](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.21.PNG)<br>

- 윈도우 크기가 4인 경우에 GBN 프로토콜의 동작<br>

    ![03.22](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.22.PNG)<br>

### 3.4.4 선택적 반복(Selective Repeat, SR)<br>

![03.23](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.23.PNG)<br>

- GBN 문제 
    1. 윈도우 크기와  밴드폭-지연 곱의 결과가 모두 클 때, 많은 패킷들이 파이프라인에 있을 수 있는 문제 존재
    2. 패킷 하나의 오류 때문에 많은 패킷을 재전송하여 많은 패킷을 불필요하게 재전송하는 경우가 발생
- SR 방식 : 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송
- 윈도우 크기는 파이프라인에서 아직 확인응답이 안 된 패킷 수를 제한하지만 GBN과 다르게 송신자는 윈도우에서 몇몇 패킷에 대한 ACK를 이미 수신
- SR 이벤트와 행동
    1. 송신자<br>

        ![03.24](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.24.PNG)<br>

    2. 수신자<br>

        ![03.25](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.25.PNG)<br>

- 손실된 패킷이 나타날 때까지의 SR 동작의 예<br>

    ![03.26](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.26.PNG)<br>

- SR 문제<br>

    ![03.27](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.27.PNG)<br>
    
    1. 송신자와 수신자의 윈도우가 항상 같지는 않다.
    2. 동기화의 부족은 순서번호의 한정된 범위에 직면했을 때 패킷의 재전송을 구별할 수 없다.
    3. 윈도우 크기는 SR 프로토콜에 대한 순서번호 공간 크기의 절반보다 작거나 같아야 한다.

## 3.5 연결지향형 트랜스포트: TCP

### 3.5.1 TCP 연결

- 연결지향형 : TCP는 두 프로세스가 서로 hand-shake를 먼저 해야한다.
- 오직 종단 시스템에서만 동작하고 중간의 네트워크 요소에서는 동작하지 않는다.
- 중간의 네트워크 요소들은 TCP 연결 상태를 유지하지 않는다.
- full-duplex : 애플리케이션 계층 데이터는 B에서 A로 흐르는 동시에 A에서 B로 흐를 수 있다.
- point-to-point : 단일 송신자와 단일 수신자 사이의 점대점 연결
- 클라이언트 프로세스 : 연결을 초기화 한다.
- 서버 프로세스 : 클라이언트의 요청을 처리한다.
- three-way handshake
    1. 클라이언트가 먼저 TCP 세그먼트를 서버에게 전송
    2. 서버는 다른 TCP 세그먼트로 응답
    3. 클라이언트가 세 번째 세그먼트로 다시 응답, 페이로드 포함 가능
- TCP는 초기 three-way handshake 동안 준비된 버퍼의 하나인 연결의 송신 버퍼로 데이터를 전송한다.
- maximum segment size, MSS : 세그먼트에서의 애플리케이션 계층 데이터에 대한 최대 크기
    1. 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이에 의해 일단 결정
    2. TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다.
- TCP 세그먼트
    1. TCP 헤더와 클라이언트 데이터를 하나로 만든 패킷
    2. TCP가 상대에게서 세그먼트를 수신했을 때, 세그먼트의 데이터는 TCP 연결의 수신 버퍼에 위치

### 3.5.2 TCP 세그먼트 구조<br>

![03.29](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.29.PNG)<br>

- 헤더 필드와 데이터 필드로 구성
- 32비트 순서번호 필드와 32비트 확인응답번호 필드 : TCP 송신자와 수신자가 신뢰적인 데이터 전송을 위해 사용
- 16비트 수신 윈도우 : 수신자가 받아들이려는 바이트의 크기
- 4비트 헤더 길이 : 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다.
- 옵션 필드 : 선택적이고 가변적인 길이의 필드로 여러 목적으로 사용된다.
- 6비트 플래그 필드
    1. ACK : 확인응답 필드에 있는 값이 유효함
    2. CWR, ECE : 명시적 혼합표시
    3. RST, SYN, FIN : 연결 설정과 해제에 사용
    4. PSH : 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킨다.
    5. URG : 이 세그먼트에서 송신 측 상위 계층 객체가 긴급으로 표시 하는 데이터임을 가리킨다.
- 16비트 긴급 데이터 포인터 필드 : 긴급 데이터의 마지막 바이트의 위치
- **순서번호와 확인응답 번호**<br>
    
    ![03.30](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.30.PNG)<br>

    - TCP는 데이터를 구조화되어 있지 않고, 단지 순서대로 정렬된 바이트 스트림으로 본다.
    - 세그먼트에 대한 순서번호는 세그먼트에 있는 첫 번째 바이트의 바이트-스트림 번호
    - 호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서번호
    - TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인 응답하기 때문에, 누적 확인응답을 제공
- **Telnet: 순서번호와 확인번호 사례 연구**<br>

    ![03.31](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.31.PNG)<br>


