---
toc: true
toc_sticky: true
categories:
- Computer Networking
title: "컴퓨터 네트워킹, [CHAPTER 03] 트랜스포트 레이어"
---

## 3.1 트랜스포트 계층 서비스 및 개요

- 서로 다른 호스트에서 동작하는 애플리케이션 프로세스들 간의 논리적 통신을 제공
- 종단 시스템에서 구현
- Segment : 트랜스포트 계층 패킷

### 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계<br>

![03.01](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.01.PNG)<br>

- 트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 프로세스들 사이의 논리적 통신 제공
- 네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신 제공

### 3.1.2 인터넷 트랜스포트 계층의 개요

- UDP : 애플리케이션에게 비신뢰적이고 비연결형인 서비스 제공
- TCP
    1. 애플리케이션에게 신뢰적이고 연결지향형 서비스를 제공
    2. 흐름제어, 순서번호, 확인응답, 타이머를 사용하여 데이터가 순서대로 정확하게 전달되도록 처리
    3. 혼잡 제어 가능
- IP
    1. 최선형 전달 서비스
    2. 세그먼트 전달외엔 어떤 보장도 없음
    3. 비신뢰적 서비스

## 3.2 다중화와 역다중화<br>

![03.02](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.02.PNG)<br>

- 역다중화(demultiplexing) : 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
- 다중화(multiplexing) : 소켓으로부터 데이터를 모으고, 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업
- 한 계층 에서의 한 프로토콜이 그 상위 계층의 여러 프로토콜에 의해 사용될 때마다 역다중화, 다중화가 필요함
- 세그먼트의 출발지 포트 번호, 목적지 포트 번호 필드 이용해 다중화<br>

![03.03](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.03.PNG)<br>

### 비연결형 다중화와 역다중화<br>

![03.04](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.04.PNG)<br>

- UDP 소켓의 애플리케이션 데이터 전송 과정
    1. 애플리케이션 데이터, 출발지 포트 번호, 목적지 포트 번호, 그리고 2개의 다른 값을 포함하는 트랜스포트 계층 세그먼트 생성
    2. 만들어진 세그먼트를 네트워크 계층으로 전달
    3. 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하고 수신 호스트로 전달
    4. 세그먼트가 수신 호스트에 도착하면, 세그먼트 안의 목적지 포트 번호를 검사하고 그 세그먼트를 포트로 식별되는 소켓에 전달
- 세그먼트들이 동일한 목적지 IP 주소와 목적지 포트 번호를 가지면 같은 목적지 소켓을 통해 동일한 프로세스로 향한다.
- 출발지 포트 번호는 복귀 주소의 한 부분으로 사용

### 연결지향형 다중화와 역다중화<br>

- TCP 소켓은 UDP 소켓과 다르게 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별
- 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다. 

### 웹 서버와 TCP<br>

![03.05](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.05.PNG)<br>

- 웹 서버는 각각의 연결에 따라서 새로운 프로세스를 만든다.
- 프로세스들은 각자 연결 소켓을 가지며, 이 연결 소켓을 통해서 HTTP 요청을 수신하고, HTTP 응답을 전송한다.
- 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것은 아니다. -> 연결 소켓에 대한 멀티 쓰레딩
- 지속적인 HTTP : 클라이언트와 서버는 동일한 서버 소켓을 통해서 HTTP 메시지를 교환
- 비지속적인 HTTP
    1. 요청/응답마다 새로운 TCP 연결이 생성되고 종료
    2. 빈번한 소켓 생성과 종료는 서버에게 부담

## 3.3 비연결형 트랜스포트 UDP

- UDP는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.
- hand-shake 사용하지 않는다 -> 비연결형
- UDP를 사용하는 애플리케이션 계층 프로토콜<br>

    ![03.06](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.06.PNG)<br>

- UDP의 장점
    1. 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어
    2. 연결 설정을 위한 지연이 없다.
    3. 연결 상태 유지를 위한 자원을 사용하지 않는다.
    4. 작은 패킷 헤더 오버헤드
- 애플리케이션이 UDP를 사용할 때도 신뢰적인 데이터 전송이 가능

### 3.3.1 UDP 세그먼트 구조<br>

![03.07](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.07.PNG)<br>

- 데이터 필드 : 애플리케이션 데이터
- UDP 헤더
    1. 2바이트씩 구성된 4개의 필드를 가진다.
    2. 체크섬 : 세그먼트에 오류가 발생했는지 검사
    3. 길이 필드 : 헤더를 포함하는 UDP 세그먼트의 길이

### 3.3.2 UDP 체크섬

- 오류 검출 제공
- 검출 과정 <br>
    
    ![wrap around](/assets/img/Computer%20Networking/22-05-05-chapter-03/wrap%20around.PNG)<br>

    1. 송신 측에서 세그먼트를 16비트 워드 단위로 더한다.
    2. 이 때 발생하는 오버플로는 wrap around한다.
    3. 모두 더한 후 1의 보수를 수행
- UDP가 오류 검출을 수행하는 이유
    - 하위 계층의 신뢰성과 메모리의 오류 검사가 보장되지 않기 때문에, 종단간의 데이터 전송 서비스가 오류 검사를 제공한다면, UDP는 종단간의 트랜스포트 계층에서 오류 검사를 제공해야만 한다. -> 종단간의 원리(end-end principle)
- 오류를 검출해도 회복하기 위한 어떤 일도 하지 않는다.

## 3.4 신뢰성 있는 데이터 전송의 원리

- 신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않는다. 
- 모든 데이터는 전송된 순서대로 전달된다.
- 신뢰적 서비스의 구현<br>
    
    ![3.8](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.08.PNG)<br>

    1. rdt_send() : 데이터 전송 프로토콜의 송신 측이 호출
    2. rdt_rcv() :  패킷이 채널의 수신 측으로부터 도착했을 때 호출
    3. deliver_data() : 상위 계층에 데이터를 전달하려고 할 때 호출. 
    4. udt_send() : 다른 쪽에 패킷을 전송 

### 3.4.1 신뢰적인 데이터 전달 프로토콜의 구축

1. 완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송 : rdt1.0<br>

    ![3.9](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.09.PNG)<br>

2. 비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송 : rdt2.0<br>

    ![3.10](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.09.PNG)<br>

    - 프로토콜 상태가 현재 전송되고 있거나, 기다리고 있는 패킷이 순서번호 0또는 1을 가져야 하는지를 반영
        1. rdt2.1 송신자<br>

            ![03.11](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.11.PNG)<br>

        2. rdt2.1 수신자<br>

            ![03.12](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.12.PNG)<br>
        
    - 비트 오류를 갖는 채널을 위한 NAK 없는 신뢰적인 데이터 전송 프로토콜
        1. rdt2.2 송신자<br>

            ![03.13](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.13.PNG)<br>

        2. rdt2.2 수신자<br>

            ![03.14](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.14.PNG)<br>

3. 비트 오류와 손실 있는 채널 상에서의 신뢰적 데이터 전송 : rdt3.0

    1. rdt3.0 송신자<br>

        ![03.15](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.15.PNG)<br>

    2. rdt3.0의 동작, 얼터네이팅 비트 프로토콜<br>

        ![03.16](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.16.PNG)<br> 

### 3.4.2 파이프라인된 신뢰적 데이터 전송 프로토콜<br>

![03.18](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.18.PNG)<br>

- stop-and-wait
    1. rdt3.0과 같은 stop-and-wait 방식에서 송신자측은 ACK 패킷을 RTT + L/R 후에 다시 받을 수 있다.
    2. 실제적으로 분주하게 비트를 전송하는데만 걸린 시간은 매우 적다.

- 파이프라이닝
    1. 확인응답을 기다리지 않고 여러 패킷을 전송하도록 허용
    2. 순서번호의 범위가 더 커져야 한다.
    3. 최소한 송신자는 전송되었으나 확인응답 되지 않은 패킷을 버퍼링해야 한다.
    4. 오류 회복의 방법으로 Go-Back-N, Selective Repeat 등이 있다.

### 3.4.3 N부터 반복(Go-Back-N, GBN)<br>

![03.19](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.19.PNG)<br>

- 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.
- 확인응답이 안 된 패킷의 최대 허용 수 N보다 크지 않아야 한다.
- base : 확인응답이 안 된 가장 오래된 패킷의 순서번호
- nextseqnum : 사용되지 않은 가장 작은 순서번호(전송될 다음 패킷의 순서번호)
- 순서 번호 범위
    1. [0, base-1] : 이미 전송되고 확인응답이 된 패킷에 대응
    2. [base, nextseqnum-1] : 송신은 되었지만 아직 확인응답 되지 않은 패킷에 대응
    3. [nextseqnum, base+N-1] : 상위 계층으로부터 데이터가 도착하면 바로 전송될 수 있는 패킷
    4. base+N 이상 : 확인응답 안 된 패킷의 확인응답이 도착될 때까지 사용될 수 없다.
- 윈도우
    1. 위 그림에서 N의 범위
    2. 순서번호 공간에서 오른쪽으로 이동된다.
- 순서번호의 범위 : k가 패킷 순서번호 필드의 비트 수라면 [0, 2^k - 1]
- ACK 기반의 NAK 없는 GBN 프로토콜의 송신 측과 수신 측의 확장된 FSM
    1. 송신자<br>

        ![03.20](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.20.PNG)<br>

    2. 수신자<br>

        ![03.21](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.21.PNG)<br>

- 윈도우 크기가 4인 경우에 GBN 프로토콜의 동작<br>

    ![03.22](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.22.PNG)<br>

### 3.4.4 선택적 반복(Selective Repeat, SR)<br>

![03.23](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.23.PNG)<br>

- GBN 문제 
    1. 윈도우 크기와  밴드폭-지연 곱의 결과가 모두 클 때, 많은 패킷들이 파이프라인에 있을 수 있는 문제 존재
    2. 패킷 하나의 오류 때문에 많은 패킷을 재전송하여 많은 패킷을 불필요하게 재전송하는 경우가 발생
- SR 방식 : 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송
- 윈도우 크기는 파이프라인에서 아직 확인응답이 안 된 패킷 수를 제한하지만 GBN과 다르게 송신자는 윈도우에서 몇몇 패킷에 대한 ACK를 이미 수신
- SR 이벤트와 행동
    1. 송신자<br>

        ![03.24](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.24.PNG)<br>

    2. 수신자<br>

        ![03.25](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.25.PNG)<br>

- 손실된 패킷이 나타날 때까지의 SR 동작의 예<br>

    ![03.26](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.26.PNG)<br>

- SR 문제<br>

    ![03.27](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.27.PNG)<br>
    
    1. 송신자와 수신자의 윈도우가 항상 같지는 않다.
    2. 동기화의 부족은 순서번호의 한정된 범위에 직면했을 때 패킷의 재전송을 구별할 수 없다.
    3. 윈도우 크기는 SR 프로토콜에 대한 순서번호 공간 크기의 절반보다 작거나 같아야 한다.

## 3.5 연결지향형 트랜스포트: TCP

### 3.5.1 TCP 연결

- 연결지향형 : TCP는 두 프로세스가 서로 hand-shake를 먼저 해야한다.
- 오직 종단 시스템에서만 동작하고 중간의 네트워크 요소에서는 동작하지 않는다.
- 중간의 네트워크 요소들은 TCP 연결 상태를 유지하지 않는다.
- full-duplex : 애플리케이션 계층 데이터는 B에서 A로 흐르는 동시에 A에서 B로 흐를 수 있다.
- point-to-point : 단일 송신자와 단일 수신자 사이의 점대점 연결
- 클라이언트 프로세스 : 연결을 초기화 한다.
- 서버 프로세스 : 클라이언트의 요청을 처리한다.
- three-way handshake
    1. 클라이언트가 먼저 TCP 세그먼트를 서버에게 전송
    2. 서버는 다른 TCP 세그먼트로 응답
    3. 클라이언트가 세 번째 세그먼트로 다시 응답, 페이로드 포함 가능
- TCP는 초기 three-way handshake 동안 준비된 버퍼의 하나인 연결의 송신 버퍼로 데이터를 전송한다.
- maximum segment size, MSS : 세그먼트에서의 애플리케이션 계층 데이터에 대한 최대 크기
    1. 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이에 의해 일단 결정
    2. TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다.
- TCP 세그먼트
    1. TCP 헤더와 클라이언트 데이터를 하나로 만든 패킷
    2. TCP가 상대에게서 세그먼트를 수신했을 때, 세그먼트의 데이터는 TCP 연결의 수신 버퍼에 위치

### 3.5.2 TCP 세그먼트 구조<br>

![03.29](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.29.PNG)<br>

- 헤더 필드와 데이터 필드로 구성
- 32비트 순서번호 필드와 32비트 확인응답번호 필드 : TCP 송신자와 수신자가 신뢰적인 데이터 전송을 위해 사용
- 16비트 수신 윈도우 : 수신자가 받아들이려는 바이트의 크기
- 4비트 헤더 길이 : 32비트 워드 단위로 TCP 헤더의 길이를 나타낸다.
- 옵션 필드 : 선택적이고 가변적인 길이의 필드로 여러 목적으로 사용된다.
- 6비트 플래그 필드
    1. ACK : 확인응답 필드에 있는 값이 유효함
    2. CWR, ECE : 명시적 혼합표시
    3. RST, SYN, FIN : 연결 설정과 해제에 사용
    4. PSH : 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킨다.
    5. URG : 이 세그먼트에서 송신 측 상위 계층 객체가 긴급으로 표시 하는 데이터임을 가리킨다.
- 16비트 긴급 데이터 포인터 필드 : 긴급 데이터의 마지막 바이트의 위치
- **순서번호와 확인응답 번호**<br>
    
    ![03.30](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.30.PNG)<br>

    - TCP는 데이터를 구조화되어 있지 않고, 단지 순서대로 정렬된 바이트 스트림으로 본다.
    - 세그먼트에 대한 순서번호는 세그먼트에 있는 첫 번째 바이트의 바이트-스트림 번호
    - 호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서번호
    - TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인 응답하기 때문에, 누적 확인응답을 제공
- **Telnet: 순서번호와 확인번호 사례 연구**<br>

    ![03.31](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.31.PNG)<br>

### 3.5.3 왕복시간(RTT) 예측과 타임아웃<br>

- SampleRTT<br>

    ![03.32](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.32.PNG)<br>

    1. 세그먼트가 송신된 시간으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 시간 길이
    2. 대부분의 TCP는 한 번에 하나의 SampleRTT 측정만을 시행
    3. 라우터에서의 혼잡과 종단 시스템에서의 부하 변화 때문에 불규칙적
    4. RTT를 추정하기 위해 SampleRTT 값의 지수적 가중 이동 평균 사용<br>

        ![EstimatedRTT](/assets/img/Computer%20Networking/22-05-05-chapter-03/EstimatedRTT.PNG)<br>

- DevRTT
    1. RTT의 변화율
    2. SampleRTT가 EstimatedRTT로부터 얼마나 많이 벗어나는지에 대한 예측<br>

        ![DevRTT](/assets/img/Computer%20Networking/22-05-05-chapter-03/DevRTT.PNG)<br>
    
- **재전송 타임아웃 주기의 설정 및 관리**<br>
    
    ![TimeoutInterval](/assets/img/Computer%20Networking/22-05-05-chapter-03/TimeoutInterval.PNG)<br>

    - 타임아웃 값은 EstimateRTT에 약간의 여유 값을 더한 값으로 설정
    - SampleRTT 값에 많은 변동이 있을 때에는 여유 값이 커야 하며, 변동이 작을 때에는 작아야 한다.
    - 타임아웃이 발생할 때, TimeoutInterval의 값은 두 배로 하여 조만간 확인응답 할 후속 세그먼트에게 발생할 수 있는 조기 타임아웃을 피하도록 한다.
    
### 3.5.4 신뢰적인 데이터 전달
    
- **간소화된 TCP 송신자**<br>

    ![03.33](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.33.PNG)<br>

    1. 애플리케이션으로부터 데이터를 수신하고 세그먼트로 데이터를 캡슐화하여 IP에게 이 세그먼트를 전송
    2. TCP는 이 세그먼트를 IP로 넘길 때 타이머 시작
    3. 타임아웃시 TCP는 타임아웃 이벤트에 대해 타임아웃을 일으킨 세그먼트를 재전송하여 응답하고 타이머 다시 시작
    4. ACK를 수신했을 때 SendBase(수신 확인응답이 확인되지 않은 가장 오래된 바이트의 순서번호)와 ACK값 y를 비교
    5. y는 y바이트 이전의 모든 바이트들의 수신 확인

- **몇가지 시나리오**<br>

    1. 손실된 확인응답에 기인하는 재전송<br>

        ![03.34](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.34.PNG)<br>

    2. 세그먼트 100이 재전송되지 않는 경우<br>

        ![03.35](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.35.PNG)<br>

- **타임아웃 주기의 두 배로 설정**<br>

    ![03.36](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.36.PNG)<br>

    1. TCP는 재전송 때 마다 타임아웃 주기를 이전 값의 두 배로 설정
    2. 재전송 후에 주기는 지수적으로 증가
    3. 상위의 애플리케이션으로부터 데이터 수신과 ACK 수신 이후 타이머 시작될 때에는 EstimatedRTT와 DevRTT의 가장 최근의 값에서 가져온다.

- **빠른 재전송**<br>

    ![03.37](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.37.PNG)<br>

    - TCP 송신자가 같은 데이터에 대해 3개의 중복 확인응답을 수신한다면, 이것은 ACK된 세그먼트의 다음 3개의 세그먼트들이 분실되었음을 의미
    - 3개의 중복 ACK를 수신하는 경우에 TCP는 세그먼트의 타이머가 만료되기 이전에 손실 세그먼트를 재전송

- **GBN인가 SR인가?**

    1. TCP와 GBN의 차이
        - 많은 TCP가 순서가 바뀐 세그먼트들을 버퍼링 
        - GBN은 연속적인 패킷 모두를 재전송
    2. TCP와 SR 차이
        - TCP는 수신자가 마지막으로 올바로 수신된 순서가 맞는 세그먼트에 대해 누적 확인응답을 하기보다는 순서가 틀린 세그먼트에 대해서 선택적으로 확인응답을 하게 한다.
    3. 결론
        - TCP의 오류 복구 매커니즘은 GBN과 SR 프로토콜의 혼합으로 분류

### 3.5.5 흐름제어

- 송신자가 수신자의 버퍼를 오버플로 시키는 것을 방지하기 위해서 애플리케이션에게 흐름제어 서비스를 제공
- 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다.
- 수신 윈도우<br>

    ![03.38](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.38.PNG)<br>

    1. TCP는 송신자가 수신 윈도우라는 변수를 유지하여 흐름제어를 제공
    2. LastByteRead : 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트 수
    3. LastByteRcvd : 네트워크로부터 도착하여 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트의 수

        ![RcvBuffer](/assets/img/Computer%20Networking/22-05-05-chapter-03/RcvBuffer.PNG)<br>
        ![rwnd](/assets/img/Computer%20Networking/22-05-05-chapter-03/rwnd.PNG)<br>

    4. rwnd = 0일 때, TCP는 전송할 데이터가 있거나 또는 전송해야 할 확인응답을 가진 경우에만 호스트에게 세그먼트를 전송할 것이기 때문에, 송신 호스트가 수신 호스트의 수신 버퍼에 약간의 공간이 있는지 알 수 없다 -> 수신 윈도우가 0이면 1바이트 데이터의 세그먼트를 계속해서 전송하도록 요구

### 3.5.6 TCP 연결 관리

- three-way handshake<br>

    ![03.39](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.39.PNG)<br>

    1. 클라이언트 TCP에서 TCP 상태 전이의 일반적인 순서<br>

        ![03.41](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.41.PNG)<br>

    2. 서버측 TCP에서 TCP 상태 전이의 일반적인 순서<br>

        ![03.42](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.42.PNG)<br>

- TCP 연결 종료<br>

    ![03.40](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.40.PNG)<br>

## 3.7 TCP 혼잡 제어

- TCP의 혼잡 제어 처리 원칙
    1. 손실된 세그먼트는 혼잡을 의미하여, 이에 따라 TCP 전송률은 한 세그먼트를 손실했을 때 줄여져야 한다.
    2. 확인응답된 세그먼트는 네트워크가 송신자의 세그먼트를 수신자에게 전송된다는 것이고, 이에 따라 이전에 확인응답되지 않은 세그먼트에 대해 ACk가 도착하면, 송신자의 전송률은 증가할 수 있다.
    3. 밴드폭 탐색

- TCP 혼잡 제어 FSM<br>

    ![03.51](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.51.PNG)<br>

### 슬로 스타트<br>

![03.50](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.50.PNG)<br>

- TCP 연결이 시작될 때, 송신자는 가용 밴드폭 양을 조속히 찾고자 한다.
- 지수적 증가
    1. 첫 번째 세그먼트를 네트워크로 보내고 확인응답을 기다린다.
    2. TCP 송신자는 하나의 MSS만큼 혼잡 윈도우를 증가시키고, 2개의 MSS 세그먼트를 전송
    3. 각 확인응답 세그먼트에 대해 하나의 MSS만큼 혼잡 윈도우를 증가
- 지수적 증가가 끝나는 시점
    1. 타임아웃에 의한 손실 이벤트가 있을 경우, 송신자는 cwnd값을 1로 하고, 새로운 슬로 스타트를 시작
    2. ssthresh 값을 cwnd/2로 설정
    3. cwnd값이 ssthresh과 같으면, 슬로 스타트는 종료되고 TCP는 혼잡 회피 모드로 전환
    4. 3개의 중복 ACK들이 검출 되면, 빠른 재전송을 수행하여 빠른 회복 상태로 진입

### 혼잡 회피<br>

- 혼잡 회피 상태로 들어가는 시점에서 cwnd의 값은 대략 혼잡이 마지막 발견된 시점에서의 값의 반으로 된다.
- 매 RTT마다 하나의 MSS만큼 cwnd값을 증가
- 끝나는 시점
    1. 타임아웃이 발생했을 때와 같이 동작
    2. TCP는 cwnd 값을 반으로 하고 ssthresh값을 3개의 중복 ACK들을 수신한 시점에서의 cwnd값의 반으로 한다. 
    3. 이후 빠른 회복 상태로 진입

### 빠른 회복<br>

- cwnd 값은 잃었던 세그먼트에 대한 매 중복된 ACK를 수신할 때마다 1 MSS만큼씩 증가
- 타임아웃 발생시 슬로 스타트, 혼잡 회피에서와 같은 동작을 수행 후 슬로 스타트로 전이
- 권고 사항이지만 필수는 아닌 요소
- TCP Reno는 빠른 회복 채택<br>

    ![03.52](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.52.PNG)<br>

### AIMD <br>

![03.53](/assets/img/Computer%20Networking/22-05-05-chapter-03/03.53.PNG)<br>

- TCP 혼잡제어는 매 RTT마다 1 MSS씩 cwnd의 선형 증가와 3개의 중복 ACK 이벤트에서 cwnd의 절반으로 구성
- 이러한 이유로 혼잡제어는 가법적 증가, 승법적 감소(additive-increase, multiplicative-decrease)로 불린다. (AIMD)

### TCP 처리율의 거시적 설명

- 윈도우 크기가 w 바이트이고 왕복시간은 RTT초면, TCP의 전송률은 대략 w/RTT
- TCP는 손실 이벤트가 발생할 때까지 RTT당 하나의 MSS만큼 w를 증가
- 손실 이벤트가 발생하는 시점의 w를 W라 할 때, TCP 전송률은 W/(2*RTT)부터 W/RTT까지의 범위를 가진다.
- 따라서 연결의 평균 처리율은 아래와 같다.<br>

    ![average-throughput](/assets/img/Computer%20Networking/22-05-05-chapter-03/average-throughput.PNG)<br>